{
  "problem": {
    "title": "Implement a Queue using an Array",
    "leetcode_id": null,
    "category": "String/Array/Matrix",
    "description": "Implement a queue data structure using an array with proper enqueue, dequeue, and peek operations.",
    "assumptions": [],
    "example": {}
  },
  "solutions": [
    {
      "title": "Solution 1 – Circular Array Implementation",
      "description": "Implement queue using circular array.",
      "code": "class Queue {\n    private int[] arr;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n    \n    public Queue(int size) {\n        arr = new int[size];\n        capacity = size;\n        front = 0;\n        rear = -1;\n        this.size = 0;\n    }\n    \n    public void enqueue(int x) {\n        if (isFull()) {\n            throw new IllegalStateException(\"Queue is full\");\n        }\n        rear = (rear + 1) % capacity;\n        arr[rear] = x;\n        size++;\n    }\n    \n    public int dequeue() {\n        if (isEmpty()) {\n            throw new IllegalStateException(\"Queue is empty\");\n        }\n        int x = arr[front];\n        front = (front + 1) % capacity;\n        size--;\n        return x;\n    }\n    \n    public int peek() {\n        if (isEmpty()) {\n            throw new IllegalStateException(\"Queue is empty\");\n        }\n        return arr[front];\n    }\n    \n    public boolean isEmpty() {\n        return size == 0;\n    }\n    \n    public boolean isFull() {\n        return size == capacity;\n    }\n    \n    public int size() {\n        return size;\n    }\n}",
      "language": "java",
      "complexity": {
        "time": "O(1)",
        "space": "O(n)"
      }
    },
    {
      "title": "Solution 1 – Circular Array Implementation",
      "description": "Implement queue using circular array.",
      "code": "class Queue {\n    private int[] arr;\n    private int front;\n    private int rear;\n    private int size;\n    private int capacity;\n    \n    public Queue(int size) {\n        arr = new int[size];\n        capacity = size;\n        front = 0;\n        rear = -1;\n        this.size = 0;\n    }\n    \n    public void enqueue(int x) {\n        if (isFull()) {\n            throw new IllegalStateException(\"Queue is full\");\n        }\n        rear = (rear + 1) % capacity;\n        arr[rear] = x;\n        size++;\n    }\n    \n    public int dequeue() {\n        if (isEmpty()) {\n            throw new IllegalStateException(\"Queue is empty\");\n        }\n        int x = arr[front];\n        front = (front + 1) % capacity;\n        size--;\n        return x;\n    }\n    \n    public int peek() {\n        if (isEmpty()) {\n            throw new IllegalStateException(\"Queue is empty\");\n        }\n        return arr[front];\n    }\n    \n    public boolean isEmpty() {\n        return size == 0;\n    }\n    \n    public boolean isFull() {\n        return size == capacity;\n    }\n    \n    public int size() {\n        return size;\n    }\n}",
      "language": "java",
      "complexity": {
        "time": "O(1)",
        "space": "O(n)"
      }
    }
  ],
  "variations": [],
  "navigation": {}
}