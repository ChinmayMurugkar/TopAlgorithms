{
  "problem": {
    "title": "Remove Invalid Parentheses",
    "leetcode_id": null,
    "category": "String/Array/Matrix",
    "description": "Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.",
    "assumptions": [],
    "example": {}
  },
  "solutions": [
    {
      "title": "Solution 1 – BFS",
      "description": "Use BFS to find all valid strings with minimum removals.",
      "code": "public List removeInvalidParentheses(String s) {\n    List result = new ArrayList<>();\n    if (s == null) return result;\n    \n    Set visited = new HashSet<>();\n    Queue queue = new LinkedList<>();\n    queue.offer(s);\n    visited.add(s);\n    boolean found = false;\n    \n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n        \n        if (isValid(current)) {\n            result.add(current);\n            found = true;\n        }\n        \n        if (found) continue;\n        \n        for (int i = 0; i < current.length(); i++) {\n            if (current.charAt(i) != '(' && current.charAt(i) != ')') continue;\n            \n            String next = current.substring(0, i) + current.substring(i + 1);\n            if (!visited.contains(next)) {\n                queue.offer(next);\n                visited.add(next);\n            }\n        }\n    }\n    \n    return result;\n}\n\nprivate boolean isValid(String s) {\n    int count = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '(') count++;\n        else if (c == ')') count--;\n        if (count < 0) return false;\n    }\n    return count == 0;\n}",
      "language": "java",
      "complexity": {
        "time": "O(2^n)",
        "space": "O(n)"
      }
    },
    {
      "title": "Solution 1 – BFS",
      "description": "Use BFS to find all valid strings with minimum removals.",
      "code": "public List removeInvalidParentheses(String s) {\n    List result = new ArrayList<>();\n    if (s == null) return result;\n    \n    Set visited = new HashSet<>();\n    Queue queue = new LinkedList<>();\n    queue.offer(s);\n    visited.add(s);\n    boolean found = false;\n    \n    while (!queue.isEmpty()) {\n        String current = queue.poll();\n        \n        if (isValid(current)) {\n            result.add(current);\n            found = true;\n        }\n        \n        if (found) continue;\n        \n        for (int i = 0; i < current.length(); i++) {\n            if (current.charAt(i) != '(' && current.charAt(i) != ')') continue;\n            \n            String next = current.substring(0, i) + current.substring(i + 1);\n            if (!visited.contains(next)) {\n                queue.offer(next);\n                visited.add(next);\n            }\n        }\n    }\n    \n    return result;\n}\n\nprivate boolean isValid(String s) {\n    int count = 0;\n    for (char c : s.toCharArray()) {\n        if (c == '(') count++;\n        else if (c == ')') count--;\n        if (count < 0) return false;\n    }\n    return count == 0;\n}",
      "language": "java",
      "complexity": {
        "time": "O(2^n)",
        "space": "O(n)"
      }
    }
  ],
  "variations": [],
  "navigation": {}
}