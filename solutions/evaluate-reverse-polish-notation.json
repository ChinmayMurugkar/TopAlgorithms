{
  "problem": {
    "title": "Evaluate Reverse Polish Notation",
    "leetcode_id": 150,
    "category": "String/Array/Matrix",
    "description": "Evaluate the value of an arithmetic expression in Reverse Polish Notation.\n                \nValid operators: +, -, *, /\n                \nRules:\n\nEach operand may be an integer or another expression\nDivision between two integers should truncate toward zero\nGiven expression is always valid",
    "assumptions": [],
    "example": {
      "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
      "output": "9",
      "explanation": "((2 + 1) * 3) = 9"
    }
  },
  "solutions": [
    {
      "title": "Solution 1 – Stack Approach",
      "description": "Use a stack to evaluate RPN expressions. When we encounter an operator, pop two operands and perform the operation.",
      "code": "public int evalRPN(String[] tokens) {\n    Stack stack = new Stack<>();\n    \n    for (String token : tokens) {\n        if (isOperator(token)) {\n            int b = stack.pop();\n            int a = stack.pop();\n            int result = performOperation(a, b, token);\n            stack.push(result);\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    \n    return stack.pop();\n}\n\nprivate boolean isOperator(String token) {\n    return token.equals(\"+\") || token.equals(\"-\") || \n           token.equals(\"*\") || token.equals(\"/\");\n}\n\nprivate int performOperation(int a, int b, String operator) {\n    switch (operator) {\n        case \"+\": return a + b;\n        case \"-\": return a - b;\n        case \"*\": return a * b;\n        case \"/\": return a / b;\n        default: return 0;\n    }\n}",
      "language": "java",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "title": "Solution 2 – Optimized Stack with Switch",
      "description": "More efficient approach using switch statement and direct character comparison:",
      "code": "public int evalRPN(String[] tokens) {\n    Stack stack = new Stack<>();\n    \n    for (String token : tokens) {\n        switch (token) {\n            case \"+\":\n                stack.push(stack.pop() + stack.pop());\n                break;\n            case \"-\":\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a - b);\n                break;\n            case \"*\":\n                stack.push(stack.pop() * stack.pop());\n                break;\n            case \"/\":\n                int divisor = stack.pop();\n                int dividend = stack.pop();\n                stack.push(dividend / divisor);\n                break;\n            default:\n                stack.push(Integer.parseInt(token));\n        }\n    }\n    \n    return stack.pop();\n}",
      "language": "java",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "title": "Solution 3 – Array-based Stack",
      "description": "Using an array instead of Stack class for better performance:",
      "code": "public int evalRPN(String[] tokens) {\n    int[] stack = new int[tokens.length];\n    int top = -1;\n    \n    for (String token : tokens) {\n        if (token.equals(\"+\")) {\n            stack[top-1] = stack[top-1] + stack[top];\n            top--;\n        } else if (token.equals(\"-\")) {\n            stack[top-1] = stack[top-1] - stack[top];\n            top--;\n        } else if (token.equals(\"*\")) {\n            stack[top-1] = stack[top-1] * stack[top];\n            top--;\n        } else if (token.equals(\"/\")) {\n            stack[top-1] = stack[top-1] / stack[top];\n            top--;\n        } else {\n            stack[++top] = Integer.parseInt(token);\n        }\n    }\n    \n    return stack[0];\n}",
      "language": "java",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "title": "Error Handling Version",
      "description": "Robust implementation with proper error handling:",
      "code": "public int evalRPN(String[] tokens) {\n    if (tokens == null || tokens.length == 0) {\n        throw new IllegalArgumentException(\"Invalid input\");\n    }\n    \n    Stack stack = new Stack<>();\n    \n    for (String token : tokens) {\n        if (isOperator(token)) {\n            if (stack.size() < 2) {\n                throw new IllegalArgumentException(\"Invalid RPN expression\");\n            }\n            int b = stack.pop();\n            int a = stack.pop();\n            int result = performOperation(a, b, token);\n            stack.push(result);\n        } else {\n            try {\n                stack.push(Integer.parseInt(token));\n            } catch (NumberFormatException e) {\n                throw new IllegalArgumentException(\"Invalid token: \" + token);\n            }\n        }\n    }\n    \n    if (stack.size() != 1) {\n        throw new IllegalArgumentException(\"Invalid RPN expression\");\n    }\n    \n    return stack.pop();\n}\n\nprivate boolean isOperator(String token) {\n    return token.length() == 1 && \"+-*/\".contains(token);\n}\n\nprivate int performOperation(int a, int b, String operator) {\n    switch (operator) {\n        case \"+\": return a + b;\n        case \"-\": return a - b;\n        case \"*\": return a * b;\n        case \"/\": \n            if (b == 0) {\n                throw new ArithmeticException(\"Division by zero\");\n            }\n            return a / b;\n        default: \n            throw new IllegalArgumentException(\"Unknown operator: \" + operator);\n    }\n}",
      "language": "java"
    }
  ],
  "variations": [],
  "navigation": {
    "previous": "reverse-words-string.html",
    "next": "isomorphic-strings.html"
  }
}