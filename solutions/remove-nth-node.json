{
  "problem": {
    "title": "Remove Nth Node From End of List",
    "leetcode_id": 19,
    "category": "Linked List",
    "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
    "assumptions": [],
    "example": {
      "input": "head = [1,2,3,4,5], n = 2",
      "output": "[1,2,3,5]",
      "explanation": "Remove the 2nd node from the end (node with value 4)."
    }
  },
  "solutions": [
    {
      "title": "Solution 1 – Two Pointers (Optimal)",
      "description": "Use two pointers with a gap of n nodes to find the node to remove.",
      "code": "public ListNode removeNthFromEnd(ListNode head, int n) {\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    \n    ListNode first = dummy;\n    ListNode second = dummy;\n    \n    // Move first pointer n+1 steps ahead\n    for (int i = 0; i <= n; i++) {\n        first = first.next;\n    }\n    \n    // Move both pointers until first reaches end\n    while (first != null) {\n        first = first.next;\n        second = second.next;\n    }\n    \n    // Remove the nth node from end\n    second.next = second.next.next;\n    \n    return dummy.next;\n}",
      "language": "java",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    },
    {
      "title": "Solution 2 – Two Pass Approach",
      "description": "First pass to count nodes, second pass to remove the target node.",
      "code": "public ListNode removeNthFromEnd(ListNode head, int n) {\n    // Count total nodes\n    int count = 0;\n    ListNode current = head;\n    while (current != null) {\n        count++;\n        current = current.next;\n    }\n    \n    // Calculate position from start\n    int position = count - n;\n    \n    // Handle case where we need to remove head\n    if (position == 0) {\n        return head.next;\n    }\n    \n    // Find the node before the one to remove\n    current = head;\n    for (int i = 0; i < position - 1; i++) {\n        current = current.next;\n    }\n    \n    // Remove the node\n    current.next = current.next.next;\n    \n    return head;\n}",
      "language": "java",
      "complexity": {
        "time": "O(n)",
        "space": "O(1)"
      }
    }
  ],
  "variations": [],
  "navigation": {
    "previous": "detect-cycle.html",
    "next": "palindrome-linked-list.html"
  }
}