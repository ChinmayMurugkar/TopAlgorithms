{
  "problem": {
    "title": "LRU Cache",
    "leetcode_id": null,
    "category": "String/Array/Matrix",
    "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.",
    "assumptions": [],
    "example": {}
  },
  "solutions": [
    {
      "title": "Solution 1 – HashMap + Doubly Linked List",
      "description": "Use HashMap and doubly linked list to implement LRU cache.",
      "code": "class LRUCache {\n    private Map cache;\n    private Node head, tail;\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        cache = new HashMap<>();\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            moveToHead(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            node.value = value;\n            moveToHead(node);\n        } else {\n            Node newNode = new Node(key, value);\n            cache.put(key, newNode);\n            addNode(newNode);\n            \n            if (cache.size() > capacity) {\n                Node lru = removeTail();\n                cache.remove(lru.key);\n            }\n        }\n    }\n    \n    private void addNode(Node node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    \n    private void moveToHead(Node node) {\n        removeNode(node);\n        addNode(node);\n    }\n    \n    private Node removeTail() {\n        Node res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n    \n    class Node {\n        int key, value;\n        Node prev, next;\n        \n        Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}",
      "language": "java",
      "complexity": {
        "time": "O(1)",
        "space": "O(capacity)"
      }
    },
    {
      "title": "Solution 1 – HashMap + Doubly Linked List",
      "description": "Use HashMap and doubly linked list to implement LRU cache.",
      "code": "class LRUCache {\n    private Map cache;\n    private Node head, tail;\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        cache = new HashMap<>();\n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            moveToHead(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            node.value = value;\n            moveToHead(node);\n        } else {\n            Node newNode = new Node(key, value);\n            cache.put(key, newNode);\n            addNode(newNode);\n            \n            if (cache.size() > capacity) {\n                Node lru = removeTail();\n                cache.remove(lru.key);\n            }\n        }\n    }\n    \n    private void addNode(Node node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    \n    private void moveToHead(Node node) {\n        removeNode(node);\n        addNode(node);\n    }\n    \n    private Node removeTail() {\n        Node res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n    \n    class Node {\n        int key, value;\n        Node prev, next;\n        \n        Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n}",
      "language": "java",
      "complexity": {
        "time": "O(1)",
        "space": "O(capacity)"
      }
    }
  ],
  "variations": [],
  "navigation": {}
}