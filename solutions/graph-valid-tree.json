{
  "problem": {
    "title": "Graph Valid Tree",
    "leetcode_id": null,
    "category": "String/Array/Matrix",
    "description": "Given n nodes labeled from 0 to n-1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.",
    "assumptions": [],
    "example": {}
  },
  "solutions": [
    {
      "title": "Solution 1 – Union Find",
      "description": "Use Union Find to detect cycles and check connectivity.",
      "code": "public boolean validTree(int n, int[][] edges) {\n    if (edges.length != n - 1) return false;\n    \n    UnionFind uf = new UnionFind(n);\n    \n    for (int[] edge : edges) {\n        if (!uf.union(edge[0], edge[1])) {\n            return false;\n        }\n    }\n    \n    return uf.getCount() == 1;\n}\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n    private int count;\n    \n    public UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        count = n;\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    public boolean union(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n        \n        if (px == py) return false;\n        \n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n        \n        count--;\n        return true;\n    }\n    \n    public int getCount() {\n        return count;\n    }\n}",
      "language": "java",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    },
    {
      "title": "Solution 1 – Union Find",
      "description": "Use Union Find to detect cycles and check connectivity.",
      "code": "public boolean validTree(int n, int[][] edges) {\n    if (edges.length != n - 1) return false;\n    \n    UnionFind uf = new UnionFind(n);\n    \n    for (int[] edge : edges) {\n        if (!uf.union(edge[0], edge[1])) {\n            return false;\n        }\n    }\n    \n    return uf.getCount() == 1;\n}\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n    private int count;\n    \n    public UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        count = n;\n        \n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    public boolean union(int x, int y) {\n        int px = find(x);\n        int py = find(y);\n        \n        if (px == py) return false;\n        \n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else {\n            parent[py] = px;\n            rank[px]++;\n        }\n        \n        count--;\n        return true;\n    }\n    \n    public int getCount() {\n        return count;\n    }\n}",
      "language": "java",
      "complexity": {
        "time": "O(n)",
        "space": "O(n)"
      }
    }
  ],
  "variations": [],
  "navigation": {}
}