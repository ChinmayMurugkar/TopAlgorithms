{
  "problem": {
    "title": "Longest Common Subsequence",
    "leetcode_id": 1143,
    "category": "Dynamic Programming",
    "description": "Given two strings text1 and text2, return the length of their longest common subsequence.\n                \nDefinition: A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",
    "assumptions": [],
    "example": {
      "input": "text1 = \"abcde\", text2 = \"ace\"",
      "output": "3",
      "explanation": "The longest common subsequence is \"ace\" and its length is 3."
    }
  },
  "solutions": [
    {
      "title": "Solution 1 – Dynamic Programming (Bottom-up)",
      "description": "Use a 2D DP table where dp[i][j] represents the length of LCS of text1[0...i-1] and text2[0...j-1].",
      "code": "public int longestCommonSubsequence(String text1, String text2) {\n    int m = text1.length();\n    int n = text2.length();\n    \n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}",
      "language": "java",
      "complexity": {
        "time": "O(m*n)",
        "space": "O(m*n)"
      }
    },
    {
      "title": "Solution 2 – Space Optimized DP",
      "description": "We can optimize space by using only two rows of the DP table.",
      "code": "public int longestCommonSubsequence(String text1, String text2) {\n    int m = text1.length();\n    int n = text2.length();\n    \n    int[] prev = new int[n + 1];\n    int[] curr = new int[n + 1];\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                curr[j] = prev[j - 1] + 1;\n            } else {\n                curr[j] = Math.max(prev[j], curr[j - 1]);\n            }\n        }\n        \n        // Swap arrays\n        int[] temp = prev;\n        prev = curr;\n        curr = temp;\n    }\n    \n    return prev[n];\n}",
      "language": "java",
      "complexity": {
        "time": "O(m*n)",
        "space": "O(n)"
      }
    },
    {
      "title": "Solution 3 – Recursive with Memoization",
      "description": "Top-down approach using recursion and memoization:",
      "code": "public int longestCommonSubsequence(String text1, String text2) {\n    int m = text1.length();\n    int n = text2.length();\n    \n    int[][] memo = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        Arrays.fill(memo[i], -1);\n    }\n    \n    return lcs(text1, text2, m - 1, n - 1, memo);\n}\n\nprivate int lcs(String text1, String text2, int i, int j, int[][] memo) {\n    if (i < 0 || j < 0) {\n        return 0;\n    }\n    \n    if (memo[i][j] != -1) {\n        return memo[i][j];\n    }\n    \n    if (text1.charAt(i) == text2.charAt(j)) {\n        memo[i][j] = lcs(text1, text2, i - 1, j - 1, memo) + 1;\n    } else {\n        memo[i][j] = Math.max(\n            lcs(text1, text2, i - 1, j, memo),\n            lcs(text1, text2, i, j - 1, memo)\n        );\n    }\n    \n    return memo[i][j];\n}",
      "language": "java",
      "complexity": {
        "time": "O(m*n)",
        "space": "O(m*n) for memoization + O(m+n) for recursion stack"
      }
    },
    {
      "title": "Printing the LCS",
      "description": "To print the actual LCS, we can backtrack through the DP table:",
      "code": "public String printLCS(String text1, String text2) {\n    int m = text1.length();\n    int n = text2.length();\n    \n    int[][] dp = new int[m + 1][n + 1];\n    \n    // Fill DP table\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    // Backtrack to find the LCS\n    StringBuilder lcs = new StringBuilder();\n    int i = m, j = n;\n    \n    while (i > 0 && j > 0) {\n        if (text1.charAt(i - 1) == text2.charAt(j - 1)) {\n            lcs.insert(0, text1.charAt(i - 1));\n            i--;\n            j--;\n        } else if (dp[i - 1][j] > dp[i][j - 1]) {\n            i--;\n        } else {\n            j--;\n        }\n    }\n    \n    return lcs.toString();\n}",
      "language": "java"
    }
  ],
  "variations": [],
  "navigation": {
    "previous": "edit-distance.html",
    "next": "knapsack-problem.html"
  }
}